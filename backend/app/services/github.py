"""
GitHub service for repository analysis and file operations
Supports both authenticated and unauthenticated access
"""
import base64
import re
import requests
from typing import List, Dict, Any, Optional, Tuple
from github import Github, GithubException
import structlog
from bs4 import BeautifulSoup
import urllib.parse

from app.config import settings
from app.models import FileInfo

logger = structlog.get_logger()


class GitHubService:
    """Service for GitHub API operations with fallback to web scraping"""
    
    def __init__(self):
        # Use authenticated GitHub client if token is available
        if settings.github_token:
            self.github = Github(settings.github_token)
            self.authenticated = True
            logger.info("GitHub service initialized with authentication")
        else:
            self.github = Github()  # Unauthenticated - lower rate limits
            self.authenticated = False
            logger.info("GitHub service initialized without authentication (using public API)")
            
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SlopScan-Bot/1.0.0',
            'Accept': 'application/vnd.github.v3+json'
        })
        self.template_patterns = [
            r'template',
            r'scaffold',
            r'boilerplate',
            r'example',
            r'sample',
            r'demo',
            r'test',
            r'spec',
            r'\.test\.',
            r'\.spec\.',
            r'__tests__',
            r'__mocks__',
            r'coverage',
            r'\.coverage',
            r'node_modules',
            r'\.git',
            r'\.github/workflows',
            r'dist/',
            r'build/',
            r'target/',
            r'bin/',
            r'obj/',
            r'\.vscode',
            r'\.idea',
            r'\.DS_Store',
            r'Thumbs\.db',
        ]
        
        self.auto_generated_patterns = [
            r'generated',
            r'auto-generated',
            r'autogenerated',
            r'\.generated\.',
            r'gen/',
            r'_gen/',
            r'\.pb\.go',
            r'\.pb\.py',
            r'_pb2\.py',
            r'\.proto\.py',
            r'package-lock\.json',
            r'yarn\.lock',
            r'Pipfile\.lock',
            r'poetry\.lock',
            r'Cargo\.lock',
            r'go\.sum',
            r'composer\.lock',
            r'\.min\.js',
            r'\.min\.css',
            r'bundle\.js',
            r'webpack\.bundle',
        ]
    
    async def get_repo_structure(self, owner: str, repo: str, branch: str = "main") -> Dict[str, Any]:
        """Get the complete structure of a repository with fallback support"""
        try:
            # First try using GitHub API
            repository = self.github.get_repo(f"{owner}/{repo}")
            
            # Get all files recursively
            files = []
            contents = repository.get_contents("", ref=branch)
            
            while contents:
                file_content = contents.pop(0)
                if file_content.type == "dir":
                    contents.extend(repository.get_contents(file_content.path, ref=branch))
                else:
                    file_info = FileInfo(
                        path=file_content.path,
                        name=file_content.name,
                        size=file_content.size,
                        type=file_content.type,
                        download_url=file_content.download_url
                    )
                    files.append(file_info)
            
            # Calculate statistics
            total_files = len(files)
            total_size = sum(f.size for f in files)
            
            # Basic classification
            for file_info in files:
                file_info.is_template = self._is_template_file(file_info.path)
                file_info.is_auto_generated = self._is_auto_generated_file(file_info.path)
            
            analysis_summary = {
                "total_files": total_files,
                "total_size": total_size,
                "template_files": sum(1 for f in files if f.is_template),
                "auto_generated_files": sum(1 for f in files if f.is_auto_generated),
                "source_files": sum(1 for f in files if not f.is_template and not f.is_auto_generated),
                "languages": self._detect_languages(files),
                "file_types": self._analyze_file_types(files),
                "method": "github_api"
            }
            
            return {
                "owner": owner,
                "repo": repo,
                "branch": branch,
                "total_files": total_files,
                "total_size": total_size,
                "files": files,
                "analysis_summary": analysis_summary
            }
            
        except GithubException as e:
            if e.status == 403:
                logger.warning("GitHub API rate limit exceeded, using fallback", owner=owner, repo=repo)
                return await self.get_repo_structure_fallback(owner, repo, branch)
            elif e.status == 401:
                logger.warning("GitHub API authentication failed, using fallback", owner=owner, repo=repo)
                return await self.get_repo_structure_fallback(owner, repo, branch)
            else:
                logger.error("GitHub API error", error=str(e), owner=owner, repo=repo)
                # Try fallback for any other GitHub API error
                return await self.get_repo_structure_fallback(owner, repo, branch)
        except Exception as e:
            logger.error("Unexpected error, trying fallback", error=str(e), owner=owner, repo=repo)
            return await self.get_repo_structure_fallback(owner, repo, branch)
    
    def _is_template_file(self, file_path: str) -> bool:
        """Check if a file is likely a template or boilerplate"""
        file_path_lower = file_path.lower()
        return any(re.search(pattern, file_path_lower) for pattern in self.template_patterns)
    
    def _is_auto_generated_file(self, file_path: str) -> bool:
        """Check if a file is auto-generated"""
        file_path_lower = file_path.lower()
        return any(re.search(pattern, file_path_lower) for pattern in self.auto_generated_patterns)
    
    def _detect_languages(self, files: List[FileInfo]) -> Dict[str, int]:
        """Detect programming languages used in the repository"""
        language_extensions = {
            '.py': 'Python',
            '.js': 'JavaScript',
            '.ts': 'TypeScript',
            '.jsx': 'JavaScript',
            '.tsx': 'TypeScript',
            '.java': 'Java',
            '.cpp': 'C++',
            '.c': 'C',
            '.h': 'C/C++',
            '.go': 'Go',
            '.rs': 'Rust',
            '.rb': 'Ruby',
            '.php': 'PHP',
            '.cs': 'C#',
            '.swift': 'Swift',
            '.kt': 'Kotlin',
            '.scala': 'Scala',
            '.r': 'R',
            '.sql': 'SQL',
            '.html': 'HTML',
            '.css': 'CSS',
            '.scss': 'SCSS',
            '.less': 'LESS',
            '.vue': 'Vue',
            '.toml': 'TOML',
            '.yaml': 'YAML',
            '.yml': 'YAML',
            '.json': 'JSON',
            '.xml': 'XML'
        }
        
        languages = {}
        for file_info in files:
            ext = '.' + file_info.name.split('.')[-1] if '.' in file_info.name else ''
            if ext in language_extensions:
                lang = language_extensions[ext]
                languages[lang] = languages.get(lang, 0) + 1
        
        return languages
    
    def _analyze_file_types(self, files: List[FileInfo]) -> Dict[str, int]:
        """Analyze file types in the repository"""
        categories = {
            'source_code': 0,
            'configuration': 0,
            'documentation': 0,
            'templates': 0,
            'auto_generated': 0,
            'other': 0
        }
        
        config_extensions = {'.json', '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf', '.env'}
        doc_extensions = {'.md', '.txt', '.rst', '.adoc'}
        source_extensions = {'.py', '.js', '.ts', '.jsx', '.tsx', '.java', '.cpp', '.c', '.h', '.go', '.rs', '.rb', '.php', '.cs', '.swift', '.kt', '.scala', '.r', '.sql'}
        
        for file_info in files:
            ext = '.' + file_info.name.split('.')[-1].lower() if '.' in file_info.name else ''
            
            if file_info.is_template:
                categories['templates'] += 1
            elif file_info.is_auto_generated:
                categories['auto_generated'] += 1
            elif ext in source_extensions:
                categories['source_code'] += 1
            elif ext in config_extensions:
                categories['configuration'] += 1
            elif ext in doc_extensions:
                categories['documentation'] += 1
            else:
                categories['other'] += 1
        
        return categories
    
    async def download_file_content(self, owner: str, repo: str, file_path: str, branch: str = "main") -> Optional[str]:
        """Download the content of a specific file with fallback support"""
        try:
            # First try using GitHub API
            repository = self.github.get_repo(f"{owner}/{repo}")
            file_content = repository.get_contents(file_path, ref=branch)
            
            if file_content.encoding == "base64":
                content = base64.b64decode(file_content.content).decode('utf-8')
                return content
            else:
                return file_content.content
                
        except GithubException as e:
            if e.status in [403, 401]:
                logger.warning("GitHub API access issue, using fallback", error=str(e), file_path=file_path)
                return await self.download_file_content_fallback(owner, repo, file_path, branch)
            else:
                logger.error("Failed to download file via API, trying fallback", error=str(e), file_path=file_path)
                return await self.download_file_content_fallback(owner, repo, file_path, branch)
        except UnicodeDecodeError:
            logger.warning("Binary file detected, skipping content", file_path=file_path)
            return None
        except Exception as e:
            logger.error("Unexpected error, trying fallback", error=str(e), file_path=file_path)
            return await self.download_file_content_fallback(owner, repo, file_path, branch)
    
    async def get_repo_structure_fallback(self, owner: str, repo: str, branch: str = "main") -> Dict[str, Any]:
        """
        Fallback method using web scraping when GitHub API is not available
        """
        try:
            # Scrape repository structure from GitHub web interface
            url = f"https://github.com/{owner}/{repo}/tree/{branch}"
            logger.info("Using GitHub web scraping fallback", url=url)
            
            response = self.session.get(url)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.content, 'html.parser')
            files = []
            
            # Extract file information from the GitHub web interface
            file_rows = soup.find_all('tr', class_='js-navigation-item')
            
            for row in file_rows:
                try:
                    # Extract file name and type
                    link = row.find('a', class_='js-navigation-open')
                    if not link:
                        continue
                        
                    file_path = link.get('href', '').split('/')[-1]
                    file_name = link.text.strip()
                    
                    # Determine if it's a file or directory
                    icon = row.find('svg')
                    is_dir = 'octicon-file-directory' in str(icon) if icon else False
                    
                    if not is_dir and file_name:
                        # Get raw file URL for downloading
                        raw_url = f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{file_name}"
                        
                        file_info = FileInfo(
                            path=file_name,
                            name=file_name,
                            size=0,  # Size not available from web scraping
                            type="file",
                            download_url=raw_url
                        )
                        files.append(file_info)
                        
                except Exception as e:
                    logger.warning("Failed to parse file row", error=str(e))
                    continue
            
            # Basic classification
            for file_info in files:
                file_info.is_template = self._is_template_file(file_info.path)
                file_info.is_auto_generated = self._is_auto_generated_file(file_info.path)
            
            total_files = len(files)
            analysis_summary = {
                "total_files": total_files,
                "total_size": 0,  # Not available from web scraping
                "template_files": sum(1 for f in files if f.is_template),
                "auto_generated_files": sum(1 for f in files if f.is_auto_generated),
                "source_files": sum(1 for f in files if not f.is_template and not f.is_auto_generated),
                "languages": self._detect_languages(files),
                "file_types": self._analyze_file_types(files),
                "method": "web_scraping_fallback"
            }
            
            return {
                "owner": owner,
                "repo": repo,
                "branch": branch,
                "total_files": total_files,
                "total_size": 0,
                "files": files,
                "analysis_summary": analysis_summary
            }
            
        except Exception as e:
            logger.error("GitHub web scraping fallback failed", error=str(e))
            raise Exception(f"Failed to access repository via web scraping: {e}")

    async def download_file_content_fallback(self, owner: str, repo: str, file_path: str, branch: str = "main") -> Optional[str]:
        """
        Fallback method to download file content using raw GitHub URLs
        """
        try:
            raw_url = f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{file_path}"
            response = self.session.get(raw_url)
            response.raise_for_status()
            
            # Try to decode as UTF-8, skip binary files
            try:
                content = response.content.decode('utf-8')
                return content
            except UnicodeDecodeError:
                logger.warning("Binary file detected, skipping content", file_path=file_path)
                return None
                
        except Exception as e:
            logger.error("Failed to download file via raw URL", error=str(e), file_path=file_path)
            return None
