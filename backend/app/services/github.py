"""
GitHub service for repository analysis and file operations
Supports both authenticated and unauthenticated access
"""
import base64
import re
import requests
from typing import List, Dict, Any, Optional, Tuple
from github import Github, GithubException
from bs4 import BeautifulSoup
import urllib.parse

from app.config import settings
from app.models import FileInfo



class GitHubService:
    """Service for GitHub API operations with fallback to web scraping"""
    
    def __init__(self):
        if settings.github_token:
            self.github = Github(settings.github_token)
            self.authenticated = True
            print("Authenticated GitHub access enabled")
        else:
            self.github = Github()
            self.authenticated = False
        
        self.session = requests.Session()
        
        self.template_patterns = [
            r'template',
            r'scaffold',
            r'boilerplate',
            r'example',
            r'sample',
            r'demo',
            r'test',
            r'spec',
            r'\.test\.',
            r'\.spec\.',
            r'__tests__',
            r'__mocks__',
            r'coverage',
            r'\.coverage',
            r'node_modules',
            r'\.git',
            r'\.github/workflows',
            r'dist/',
            r'build/',
            r'target/',
            r'bin/',
            r'obj/',
            r'\.vscode',
            r'\.idea',
            r'\.DS_Store',
            r'Thumbs\.db',
        ]
        
        self.auto_generated_patterns = [
            r'generated',
            r'auto-generated',
            r'autogenerated',
            r'\.generated\.',
            r'gen/',
            r'_gen/',
            r'\.pb\.go',
            r'\.pb\.py',
            r'_pb2\.py',
            r'\.proto\.py',
            r'package-lock\.json',
            r'yarn\.lock',
            r'Pipfile\.lock',
            r'poetry\.lock',
            r'Cargo\.lock',
            r'go\.sum',
            r'composer\.lock',
            r'\.min\.js',
            r'\.min\.css',
            r'bundle\.js',
            r'webpack\.bundle',
        ]
    
    async def get_repo_structure(self, owner: str, repo: str, branch: str = "main") -> Dict[str, Any]:
        try:
            print(f"Getting repo structure for {owner}/{repo} on branch {branch}")
            
            url = f"https://api.github.com/repos/{owner}/{repo}/git/trees/{branch}?recursive=1"
            headers = {}
            if settings.github_token:
                headers['Authorization'] = f'token {settings.github_token}'
            
            response = self.session.get(url, headers=headers)
            response.raise_for_status()
            
            tree_data = response.json()
            
            files = []
            for item in tree_data.get('tree', []):
                if item['type'] == 'blob': 
                    download_url = f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{item['path']}"
                    
                    file_info = FileInfo(
                        path=item['path'],
                        name=item['path'].split('/')[-1],
                        size=item.get('size', 0),
                        type='file',
                        download_url=download_url
                    )
                    print(f'"{item['path']}", ',end="")
                    files.append(file_info)
            
            print(f"Total files fetched: {len(files)}")
            
            total_files = len(files)
            total_size = sum(f.size for f in files)
            
            for file_info in files:
                file_info.is_template = self._is_template_file(file_info.path)
                file_info.is_auto_generated = self._is_auto_generated_file(file_info.path)
            
            structure = {
                "template_files": sum(1 for f in files if f.is_template),
                "auto_generated_files": sum(1 for f in files if f.is_auto_generated),
                "actual_files": sum(1 for f in files if not f.is_template and not f.is_auto_generated),
                "languages": self._detect_languages(files),
                "file_types": self._analyze_file_types(files),
            }

            
            
            return {
                "owner": owner,
                "repo": repo,
                "branch": branch,
                "total_files": total_files,
                "total_size": total_size,
                "files": files,
                "analysis_summary": structure,
            }
            
        except requests.exceptions.RequestException as e:
            if hasattr(e, 'response') and e.response is not None:
                if e.response.status_code == 403:
                    print(f"GitHub API rate limit exceeded for {owner}/{repo}")
                    return {"error": "GitHub API rate limit exceeded"}
                elif e.response.status_code == 401:
                    print(f"GitHub API authentication failed for {owner}/{repo}")
                    return {"error": "GitHub API authentication failed"}
                elif e.response.status_code == 404:
                    print(f"Repository or branch not found for {owner}/{repo} on branch {branch}")
                    return {"error": "Repository or branch not found"}
            
            print(f"GitHub Trees API error for {owner}/{repo}")
            return {"error": "GitHub API error" }
        except Exception as e:
            print(f"Unexpected error for {owner}/{repo}")
            return {"error": "Unexpected error"}
    
    def _is_template_file(self, file_path: str) -> bool:
        """Check if a file is likely a template or boilerplate"""
        file_path_lower = file_path.lower()
        return any(re.search(pattern, file_path_lower) for pattern in self.template_patterns)
    
    def _is_auto_generated_file(self, file_path: str) -> bool:
        """Check if a file is auto-generated"""
        file_path_lower = file_path.lower()
        return any(re.search(pattern, file_path_lower) for pattern in self.auto_generated_patterns)
    
    def _detect_languages(self, files: List[FileInfo]) -> Dict[str, int]:
        """Detect programming languages used in the repository"""
        language_extensions = {
            '.py': 'Python',
            '.js': 'JavaScript',
            '.ts': 'TypeScript',
            '.jsx': 'JavaScript',
            '.tsx': 'TypeScript',
            '.java': 'Java',
            '.cpp': 'C++',
            '.c': 'C',
            '.h': 'C/C++',
            '.go': 'Go',
            '.rs': 'Rust',
            '.rb': 'Ruby',
            '.php': 'PHP',
            '.cs': 'C#',
            '.swift': 'Swift',
            '.kt': 'Kotlin',
            '.scala': 'Scala',
            '.r': 'R',
            '.sql': 'SQL',
            '.html': 'HTML',
            '.css': 'CSS',
            '.scss': 'SCSS',
            '.less': 'LESS',
            '.vue': 'Vue',
            '.toml': 'TOML',
            '.yaml': 'YAML',
            '.yml': 'YAML',
            '.json': 'JSON',
            '.xml': 'XML'
        }
        
        languages = {}
        for file_info in files:
            ext = '.' + file_info.name.split('.')[-1] if '.' in file_info.name else ''
            if ext in language_extensions:
                lang = language_extensions[ext]
                languages[lang] = languages.get(lang, 0) + 1
        
        return languages
    
    def _analyze_file_types(self, files: List[FileInfo]) -> Dict[str, int]:
        """Analyze file types in the repository"""
        categories = {
            'source_code': 0,
            'configuration': 0,
            'documentation': 0,
            'templates': 0,
            'auto_generated': 0,
            'other': 0
        }
        
        config_extensions = {'.json', '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf', '.env'}
        doc_extensions = {'.md', '.txt', '.rst', '.adoc'}
        source_extensions = {'.py', '.js', '.ts', '.jsx', '.tsx', '.java', '.cpp', '.c', '.h', '.go', '.rs', '.rb', '.php', '.cs', '.swift', '.kt', '.scala', '.r', '.sql'}
        
        for file_info in files:
            ext = '.' + file_info.name.split('.')[-1].lower() if '.' in file_info.name else ''
            
            if file_info.is_template:
                categories['templates'] += 1
            elif file_info.is_auto_generated:
                categories['auto_generated'] += 1
            elif ext in source_extensions:
                categories['source_code'] += 1
            elif ext in config_extensions:
                categories['configuration'] += 1
            elif ext in doc_extensions:
                categories['documentation'] += 1
            else:
                categories['other'] += 1
        
        return categories
    
    async def download_file_content(self, owner: str, repo: str, file_path: str, branch: str = "main") -> Optional[str]:
        """Download the content of a specific file with fallback support"""
        try:
            # First try using GitHub API
            repository = self.github.get_repo(f"{owner}/{repo}")
            file_content = repository.get_contents(file_path, ref=branch)
            
            if file_content.encoding == "base64":
                content = base64.b64decode(file_content.content).decode('utf-8')
                return content
            else:
                return file_content.content
                
        except GithubException as e:
            if e.status in [403, 401]:
                print(f"GitHub API access issue, using fallback for {file_path}")
                return await self.download_file_content_fallback(owner, repo, file_path, branch)
            else:
                print(f"Failed to download file via API, trying fallback for {file_path}")
                return await self.download_file_content_fallback(owner, repo, file_path, branch)
        except UnicodeDecodeError:
            print(f"Binary file detected, skipping content for {file_path}")
            return None
        except Exception as e:
            print(f"Unexpected error, trying fallback for {file_path}")
            return await self.download_file_content_fallback(owner, repo, file_path, branch)
    

    async def download_file_content_fallback(self, owner: str, repo: str, file_path: str, branch: str = "main") -> Optional[str]:
        """
        Fallback method to download file content using raw GitHub URLs
        """
        try:
            raw_url = f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{file_path}"
            response = self.session.get(raw_url)
            response.raise_for_status()
            
            # Try to decode as UTF-8, skip binary files
            try:
                content = response.content.decode('utf-8')
                return content
            except UnicodeDecodeError:
                print(f"Binary file detected, skipping content for {file_path}")
                return None
                
        except Exception as e:
            print(f"Failed to download file via raw URL for {file_path}")
            return None
